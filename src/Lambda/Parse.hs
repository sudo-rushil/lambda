{-|
Module      : Lambda.Parse
Description : Wrapper over the parser generated by Happy

License     : MIT
Maintainer  : Rushil Mallarapu
-}

module Lambda.Parse
    ( parse
    , Error(..)
    , ErrClass(..)
    ) where


import qualified Data.ByteString.Lazy as B
import           Data.List            (isPrefixOf)

import           Lambda.Lex           (runAlex)
import           Lambda.Parser        (happyParser)
import           Lambda.Syntax


data ErrClass = Syntactical (Maybe String)
    | Lexical
    | Message String
    deriving (Show, Eq)


data Error = Error
    { errLine  :: Int
    , errPos   :: Int
    , errClass :: ErrClass
    }
    deriving (Show, Eq)


parse :: B.ByteString -> Either Error [Stmt]
parse s =
    let showErrPrefix = "show-error: " :: String
        lexicalErrPrefix = "lexical error at line " :: String
    in case runAlex s $ happyParser of
        Right x -> Right (reverse x) -- stmts get parsed in reverse
        Left str | showErrPrefix `isPrefixOf` str ->
                    let (line, column, m) =
                            (read (drop (length showErrPrefix) str) :: (Int, Int, Maybe String))
                    in Left (Error line column (Syntactical m))
                 | lexicalErrPrefix `isPrefixOf` str ->
                    let info = drop (length lexicalErrPrefix) str
                        lineStr = takeWhile (/= ',') info
                        columnStr = drop (9 + length lineStr) info
                    in Left (Error (read lineStr) (read columnStr) Lexical)
                 | otherwise -> Left (Error 0 0 (Message str))
